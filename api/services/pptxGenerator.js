const fs = require("fs");
const path = require("path");
const { v4: uuidv4 } = require("uuid");
const config = require("../config");

/**
 * Execute generated PPTX code and return the file path
 * @param {string} generatedCode - JavaScript code generated by LLM
 * @param {string} jobId - Unique job identifier
 * @returns {string} - Path to generated PPTX file
 */
async function executePptxCode(generatedCode, jobId) {
  const outputDir = path.resolve(config.OUTPUT_DIR);
  const mediaDir = path.resolve(config.MEDIA_DIR);

  // Ensure directories exist
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  if (!fs.existsSync(mediaDir)) {
    fs.mkdirSync(mediaDir, { recursive: true });
  }

  // Create a temporary file for the generated code
  const tempCodePath = path.join(outputDir, `temp_${jobId}.js`);
  const outputFileName = `presentation_${jobId}.pptx`;
  const outputPath = path.join(outputDir, outputFileName);

  // Modify the code to use absolute paths and return the correct output path
  let modifiedCode = generatedCode;

  // Replace output file path with absolute path
  modifiedCode = modifiedCode.replace(
    /['"]presentation\.pptx['"]/g,
    `'${outputPath.replace(/\\/g, "/")}'`
  );

  modifiedCode = modifiedCode.replace(
    /['"]\.\/output\/presentation\.pptx['"]/g,
    `'${outputPath.replace(/\\/g, "/")}'`
  );

  // Replace media dir with absolute path
  modifiedCode = modifiedCode.replace(
    /path\.join\(__dirname,\s*["']media["']\)/g,
    `'${mediaDir.replace(/\\/g, "/")}'`
  );

  modifiedCode = modifiedCode.replace(
    /['"]\.\/media['"]/g,
    `'${mediaDir.replace(/\\/g, "/")}'`
  );

  // Replace imageHelper.js path with absolute path to api folder
  const imageHelperPath = path
    .resolve(__dirname, "..", "imageHelper.js")
    .replace(/\\/g, "/");
  modifiedCode = modifiedCode.replace(
    /require\(['"]\.\/imageHelper\.js['"]\)/g,
    `require('${imageHelperPath}')`
  );

  // Replace the mongoService path (if any)
  modifiedCode = modifiedCode.replace(
    /require\(['"]\.\/services\/mongoService\.js['"]\)/g,
    `require('${path
      .resolve(__dirname, "mongoService.js")
      .replace(/\\/g, "/")}')`
  );

  // Write the modified code to temp file
  fs.writeFileSync(tempCodePath, modifiedCode, "utf-8");
  console.log(`üìù Wrote temp code to: ${tempCodePath}`);

  try {
    // Clear require cache for the temp file (in case of re-runs)
    delete require.cache[require.resolve(tempCodePath)];

    // Execute the code
    const generator = require(tempCodePath);

    if (typeof generator.generatePresentation === "function") {
      await generator.generatePresentation();
    } else {
      // If the code doesn't export the function, it might auto-execute
      // Give it a moment to complete
      await new Promise((resolve) => setTimeout(resolve, 2000));
    }

    // Check if the file was created
    if (fs.existsSync(outputPath)) {
      console.log(`‚úÖ PPTX generated: ${outputPath}`);
      return outputPath;
    } else {
      // Try to find any generated pptx file
      const files = fs.readdirSync(outputDir);
      const pptxFile = files.find(
        (f) => f.endsWith(".pptx") && f.includes(jobId)
      );
      if (pptxFile) {
        return path.join(outputDir, pptxFile);
      }
      throw new Error("PPTX file was not generated");
    }
  } finally {
    // Clean up temp file
    try {
      fs.unlinkSync(tempCodePath);
    } catch (e) {
      console.warn("‚ö†Ô∏è Could not delete temp file:", e.message);
    }
  }
}

/**
 * Alternative: Direct PPTX generation without LLM
 * This is a fallback that generates PPTX directly from JSON
 */
async function generatePptxDirect(presentationJson, imageVars, jobId) {
  const PptxGenJS = require("pptxgenjs");

  const outputDir = path.resolve(config.OUTPUT_DIR);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  const pptx = new PptxGenJS();
  const PPTX_LAYOUT_WIDTH_IN = 10;
  const PPTX_LAYOUT_HEIGHT_IN = 5.625;

  pptx.defineLayout({
    name: "LAYOUT_16x9",
    width: PPTX_LAYOUT_WIDTH_IN,
    height: PPTX_LAYOUT_HEIGHT_IN,
  });
  pptx.layout = "LAYOUT_16x9";

  const PPTX_PX_W = PPTX_LAYOUT_WIDTH_IN * 96;
  const PPTX_PX_H = PPTX_LAYOUT_HEIGHT_IN * 96;
  const pxToIn = (px) => px / 96;

  const slides = presentationJson.slides || presentationJson;

  for (const slideData of slides) {
    const slide = pptx.addSlide();

    // Handle background
    if (slideData.background) {
      const m = slideData.background.match(/\d+/g);
      if (m) {
        const rgb = m
          .slice(0, 3)
          .map((n) => parseInt(n).toString(16).padStart(2, "0"))
          .join("");
        slide.background = { color: rgb };
      }
    }

    // Calculate scale factors
    const stageRect = (slideData.objects || []).find(
      (o) =>
        o.type === "Rect" && o.left === 0 && o.top === 0 && o.width && o.height
    );
    const designPxW = stageRect
      ? stageRect.width * (stageRect.scaleX || 1)
      : PPTX_PX_W;
    const designPxH = stageRect
      ? stageRect.height * (stageRect.scaleY || 1)
      : PPTX_PX_H;
    const scaleX = PPTX_PX_W / designPxW;
    const scaleY = PPTX_PX_H / designPxH;

    for (const obj of slideData.objects || []) {
      const objLeftPx = (obj.left || 0) * scaleX;
      const objTopPx = (obj.top || 0) * scaleY;
      const objWpx = (obj.width || 100) * (obj.scaleX || 1) * scaleX;
      const objHpx = (obj.height || 50) * (obj.scaleY || 1) * scaleY;

      let x = pxToIn(objLeftPx);
      let y = pxToIn(objTopPx);
      const w = pxToIn(objWpx);
      const h = pxToIn(objHpx);

      // Adjust for origin
      if (obj.originX === "center") x -= w / 2;
      else if (obj.originX === "right") x -= w;
      if (obj.originY === "center" || obj.originY === "middle") y -= h / 2;
      else if (obj.originY === "bottom") y -= h;

      if (obj.type === "Textbox") {
        let rgb = "000000";
        try {
          const m = (obj.color || obj.fill || "").match(/\d+/g);
          if (m)
            rgb = m
              .slice(0, 3)
              .map((n) => parseInt(n).toString(16).padStart(2, "0"))
              .join("");
        } catch (e) {}

        let align = "left";
        if (obj.textAlign?.includes("center")) align = "center";
        else if (obj.textAlign?.includes("right")) align = "right";

        const fontPx = (obj.fontSize || 12) * (obj.scaleY || 1) * scaleY;
        const fontPt = Math.max(8, Math.round(fontPx * 0.75));

        slide.addText(obj.text || "", {
          x,
          y,
          w,
          h,
          fontSize: fontPt,
          fontFace: obj.fontFamily || "Arial",
          color: rgb,
          align,
          valign: "middle",
          bold: obj.fontWeight === "bold" || obj.fontWeight === "700",
        });
      } else if (obj.type === "Rect") {
        // Skip stage background rect
        const isStageRect =
          obj.left === 0 &&
          obj.top === 0 &&
          (obj.width || 0) * (obj.scaleX || 1) * scaleX >= PPTX_PX_W * 0.95;
        if (isStageRect) {
          const m = (obj.fill || "rgba(255,255,255,1)").match(/\d+/g);
          if (m) {
            const bgRgb = m
              .slice(0, 3)
              .map((n) => parseInt(n).toString(16).padStart(2, "0"))
              .join("");
            slide.background = { color: bgRgb };
          }
          continue;
        }

        let rgb = "FFFFFF";
        try {
          const m = (obj.fill || "").match(/\d+/g);
          if (m)
            rgb = m
              .slice(0, 3)
              .map((n) => parseInt(n).toString(16).padStart(2, "0"))
              .join("");
        } catch (e) {}

        slide.addShape(pptx.ShapeType.rect, {
          x,
          y,
          w,
          h,
          fill: { color: rgb },
        });
      } else if (obj.type === "Image" && obj.src) {
        try {
          if (obj.src.startsWith("var") && imageVars[obj.src]) {
            slide.addImage({ data: imageVars[obj.src], x, y, w, h });
          } else if (
            !obj.src.startsWith("var") &&
            !obj.src.startsWith("data:")
          ) {
            // External URL or path
            slide.addImage({ path: obj.src, x, y, w, h });
          }
        } catch (error) {
          console.error(`‚ùå Error adding image:`, error.message);
        }
      }
    }
  }

  const outputPath = path.join(outputDir, `presentation_${jobId}.pptx`);
  await pptx.writeFile({ fileName: outputPath });
  console.log(`‚úÖ PPTX generated: ${outputPath}`);

  return outputPath;
}

module.exports = {
  executePptxCode,
  generatePptxDirect,
};
